---
title: Amazon DynamoDBの基礎知識のメモ
date: 2024-10-07T07:15:00
tags:
  - AWS
  - DynamoDB
  - NoSQL
description: "自分用のメモとして、DynamoDBのコアコンポーネント（テーブル、アイテム、属性）、プライマリキー、セカンダリインデックス、DynamoDB Streamsについて整理。設計に役立つベストプラクティスも含む"
---

[What is Amazon DynamoDB?](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html)のIf you're a first-time user of DynamoDB, we recommend that you begin by reading the following topics:を順番に読んでいく

## Core components of Amazon DynamoDB

### [Tables, items, and attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html)

Amazon DynamoDBは、3つの主要なコアコンポーネントで構成されています。

1. Tables（テーブル）

   - データのストレージとして機能します。
   - Items（item）の集合体であり、データを格納します。
   - 一般的なデータベースのテーブルのような役割を果たします。

2. Items（item）

   - 各テーブルには0個以上のitemが含まれます。
   - itemは、属性（attributes）のグループで構成されています。
   - 各itemはユニークであり、主キー（primary key）を使用して識別されます。
   - 一般的なデータベースの行やレコードに相当します。
   - 主キー以外の属性はスキーマレスで、事前に属性やそのデータ型を定義する必要はありません。
   - 各itemは独自の属性を持つことができ、全てのitemが同じ属性を持つ必要はありません。

3. Attributes（属性）

   - 各itemには1つ以上の属性が含まれます。
   - 属性は、データを格納する最小単位です。
   - 一般的なデータベースのフィールドやカラムに相当します。
   - 多くの属性はスカラー型（文字列や数値などの単一の値）ですが、ネストされた属性もサポートしており、32階層まで深くネスト可能です。

### Primary key

Primary Keyは、テーブル内の各Itemを一意に識別するためのキーです。

Primary Keyには2種類があります。

1. Partition key
   1. 1つの属性で構成される単純なPrimary Keyです。
   2. Partition Keyの値はDynamoDBの内部ハッシュ関数の入力として使用され、得られたハッシュ値をもとに異なる物理パーティションに分散してItemが格納されます。

2. Partition key and sort key
   1. 2つの属性で構成される複合的なPrimary Keyです。Partition KeyとSort Keyで構成されます。
   2. Partition Keyの値に基づいて、DynamoDBの内部ハッシュ関数が実行され、その結果に応じてデータが物理パーティションに割り当てられます。
   3. Sort Keyは同じPartition Key内でのitemの順序を決定し、DynamoDBはSort Keyの値に基づいてitemをソートして保存します。
   4. 同じPartition Keyを持つ複数のitemを格納できますが、その場合はSort Keyの値が一意である必要があります。

Partition Keyに許可されているデータ型は、String、Number、Binaryのいずれかです。
補足：

- Partition Keyは"Hash attribute"とも呼ばれ、内部ハッシュ関数に基づきデータが均等に分散されます。
- Sort Keyは"Range attribute"とも呼ばれ、同じPartition Keyを持つitemを物理的に近い場所に並べ、Sort Keyの値でソートします。

## [Secondary indexes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SecondaryIndexes.html)

- Secondary indexesは、テーブルのプライマリキーとは異なるキーを使ってクエリを実行するための代替手段。
- 必須ではないが、クエリの柔軟性を高める役割を持つ。
- indexからのデータ取得方法は、テーブルからのデータ取得方法とほぼ同じ。
- すべてのindexはテーブルに所属する。

Secondary Indexesには2種類があります。

1. Global Secondary Index (GSI)  
   - パーティションキーとソートキーの両方を、元のテーブルとは異なるキーで定義できる。
     - パーティションキーだけで定義することも可能です。ソートキーはオプションです。
   - テーブル全体に対してindexを作成する。
   - すべてのパーティションキーをまたいでクエリを実行できる。
   - 最大20個のGSIを作成可能。

2. Local Secondary Index (LSI)  
   - パーティションキーは元のテーブルと同じだが、ソートキーのみ異なるものを設定できる。
   - 同じパーティションキー内のデータに対してindexを作成する。
   - 最大5個のLSIを作成可能。

indexの管理と属性の投影

- DynamoDBはindexを自動で管理:
  - テーブルに対してitemが追加、更新、削除されると、index内の対応するitemも自動的に更新される。
- 投影属性の指定:
  - 最低限プライマリキーが投影される。
  - その他の属性も選択可能で、必要に応じてindexに複製できる。

## [DynamoDB Streams](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html)

オプション機能でDynamoDBテーブルのデータ変更イベントをほぼリアルタイムで記録します。イベントは発生順にストリーム内に表示され、各イベントはstream recordとして表されます。

データ変更イベントは3種類あります：

1. 新しいitemの追加
   1. item全体（全属性を含む）のスナップショットがキャプチャされます。
2. itemの更新
   1. 変更された属性に関して、更新前と更新後のスナップショットがキャプチャされます。
3. itemの削除
   1. 削除される前のitem全体のスナップショットがキャプチャされます。

各stream recordには以下の情報が含まれます：

1. テーブル名
2. イベントのタイムスタンプ
3. その他のメタデータ

stream recordの有効期間は24時間で、その後自動的に削除されます。

## Best practices for designing and architecting with DynamoDB

### Two key concepts for NoSQL design

1. スキーマ設計よりもユースケースの理解を優先する
   - アプリケーションのユースケースやビジネス上の問題を前もって理解することが重要
2. テーブル数を最小限にする
   - スケーラビリティの向上
   - 権限管理の簡素化
   - アプリケーションのオーバーヘッド削減
   - バックアップコストの低減

### Approaching NoSQL design

#### Application’s Access Patterns: 必須クエリパターンを理解する

1. Data Size (データ量)
    1. 1回のリクエストで読み書きされるデータ量を把握することが重要。
    2. これにより、効率的にデータをパーティション化するために役立つ。
2. Data Shape (データ形状)
    1. クエリされるデータに応じて、事前にデータを整形して保存する。
    2. これにより、処理速度とスケーラビリティが向上する。
3. Data Velocity (データ速度)
    1. ピーク時のクエリ負荷を予想する。
    2. これにより、データを適切にパーティション化することでI/Oキャパシティを効率的に利用できる。
    3. スケールするとは、"クエリで利用できる物理パーティションを増やし、そのパーティションにデータを分散させる"こと

<details>

<summary>DynamoDBのスケーリングとパーティションの動作</summary>

##### DynamoDBのパーティショニングの基本

DynamoDBは、Partition Key（ハッシュキー）を使ってデータを分散します。このPartition Keyは、データの物理パーティションにどこに格納するかを決めるために使われます。つまり、ハッシュ関数を使ってPartition Keyを計算し、対応する物理パーティションにデータが格納されます。

この仕組みによって、均等にデータが分散されるため、どのクエリも一定の速度で処理されるようになります。これは、DynamoDBが大量のデータとクエリをスケーラブルに処理するための基盤となる仕組みです。

**物理パーティションの役割**

しかし、DynamoDBは負荷やデータ量が増加したとき、自動的に物理パーティションを増やすことで、さらなるスケーリングを実現します。ここで重要なのは、DynamoDBがテーブルのスループット（読み書き容量）やデータサイズに応じて物理パーティションを分けることで、データアクセスの競合を減らし、パフォーマンスを向上させるという点です。

物理パーティションの数が増えると、次のような効果が得られます。

 1. クエリの負荷分散
    1. クエリが各物理パーティションに対して均等に分散されるため、1つのパーティションに対する負荷が集中するのを避けられます。例えば、負荷が1つのパーティションに集中すると、そのパーティションのI/O容量が限界に達し、クエリの速度が低下しますが、物理パーティションが増えれば、負荷が分散され、各パーティションがより少ないデータを処理することになります。
 2. I/O容量の増加
    1. 物理パーティションを増やすことで、DynamoDBはパーティションごとに割り当てられるI/O容量（読み取り/書き込みスループット）も増加させます。これにより、全体のスループットが増え、より多くの同時クエリを効率的に処理できるようになります。

なぜ物理パーティションが増えると速度が上がるのか？

DynamoDBはテーブルに対して物理パーティションを自動で追加することによって、以下のような理由で速度やスケーラビリティが向上します。

 1. 負荷分散の効率化
    1. 1つのパーティションに多くのクエリやデータが集中すると、**「ホットパーティション」**と呼ばれる状態が発生し、そのパーティションのリソースが不足するため、クエリが遅くなることがあります。物理パーティションを増やすことで、データとクエリの負荷を分散させ、各パーティションにかかる負荷を減らすことができます。
 2. パーティションごとのスループットの割り当て
    1. DynamoDBは各パーティションに対して特定の読み取り/書き込みキャパシティを割り当てます。パーティションが増えることで、全体のスループットも増加し、結果的にパフォーマンスが向上します。つまり、物理パーティションが増えることで、各パーティションの処理能力が増強され、クエリや書き込み速度が向上します。

</details>

<details>

<summary>Data Velocityについての例</summary>

##### 例: オンラインショッピングサイトでのDynamoDBスケーリングとセカンダリーインデックス

**シナリオ: セール時のピーククエリ**

オンラインショッピングサイトでは、毎日夜8時にセールが開始されると、以下のクエリが大量に発生すると予想されています。

1. **商品検索クエリのピーク**  
   ユーザーが「スマホケース」など、特定のカテゴリの商品を大量に検索する。

   - **対応策**:  
     DynamoDBで、Global Secondary Index (GSI) を使用して「商品カテゴリ」をパーティションキーに設定します。これにより、「スマホケース」というカテゴリの全商品を素早く検索できるようになります。結果として、ピーク時のクエリ処理を効率化し、スループットを維持できます。

   - **インデックス例**:  
     - パーティションキー: 商品カテゴリ  
     - ソートキー: 商品名

2. **注文履歴クエリのピーク**  
   多くのユーザーがセール後に「自分の注文履歴」を確認する。

   - **対応策**:  
     Local Secondary Index (LSI) を使用して、「ユーザーID」をパーティションキー、「注文日時」をソートキーにしたインデックスを作成します。これにより、ユーザーが自身の最近の注文履歴を素早く取得できるようになり、ピーク時でもスループットが維持されます。

   - **インデックス例**:  
     - パーティションキー: ユーザーID  
     - ソートキー: 注文日時

</details>

### you can organize data according to general principles that govern performance: パフォーマンスを左右する一般的な原則に従ってデータを整理

1. Keep related data together (リレーショナルデータは一緒にまとめる)
   1. “locality of reference"の原則(principle)に従う。
      1. 関連データを近くに置くことで、アクセス時のパフォーマンス向上が期待できるという考え
   2. 関連するデータを一つの場所(テーブル)に一緒にまとめる
      1. これは必ずしもリレーショナルデータを1つのItemにすることを意味するわけではない。
   3. 一般的なルールとして、DynamoDBアプリケーション内ではできるだけ少ないテーブルを維持するべき
      1. 例外として、高トラフィックな時系列データや、アクセスパターンが大きく異なるデータセットの場合は、複数のテーブルを使用することが適切。
2. Use sort order(sort keyを使う)
   1. データのグルーピングとは、PartitionKeyを同じにし、SortKeyを使って関連するデータを識別・整理すること
   2. これによりクエリが効率的になる
      1. PartitionKeyだけで検索すれば、そのキーに対応するすべてのデータ（同じグループのデータ）が一括で取得できます
      2. SortKeyを日付などに設定しておけば、範囲クエリが効率的にできます。
   3. この考えはNoSQLにおいて、重要なデザイン戦略
3. Distribute queries (クエリを分散させる)
   1. [Using write sharding to distribute workloads evenly in your DynamoDB table](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-sharding.html)
   2. `hot spots`とは、特定の物理パーティションにクエリが集中することで、そのパーティションのI/Oキャパシティを超え、結果として`latency`(遅延時間)が増大し、パフォーマンスが低下する現象です。
   3. 特定の`partition key`にクエリが集中しないようにするため、キー設計を工夫する必要があります。
      1. 例えば、`partition key`が `log001` の場合:
         - 元々のキーが `log001` だとすると、クエリが集中してホットスポットが発生する可能性があります。
         - そこで、`log001-2014-07-09.1`や`log001-2014-07-09.2` のように、同じ `log001` を分割して使用することでトラフィックを均等に分散させます。
4. Use global secondary indexes(GSIを使う)
   1. テーブル自体が持つキーとは異なるキーに基づいた効率的なクエリが可能になります。
   2. 非常に高速かつ比較的安価に実行できる

<details>

<summary>DynamoDBにおける反転インデックスの例</summary>

反転インデックス（inverted index）は、データベースや検索エンジンで使用される索引の一種で、一般的には特定の値がどのレコード（アイテム）に関連しているかを素早く見つけるための仕組みです。DynamoDBのコンテキストでは、反転インデックスはテーブルの構造を最適化するために使用され、クエリやスキャンのパフォーマンスを向上させるための技法です。

**DynamoDBにおける反転インデックスの例**

DynamoDBでは「単一テーブル設計」を使用することが一般的で、その中で反転インデックスを活用して、異なるクエリパターンに対応できるようにすることができます。この場合、Global Secondary Index（GSI）を反転インデックスとして設定します。
通常の設計では、パーティションキーとソートキーの組み合わせでデータを検索します。しかし、あるクエリでは別の項目をキーとして検索したい場合があるかもしれません。そこで、反転インデックスを使用すると、検索したい項目を新たなインデックス（GSI）に割り当てることができます。

具体例：
例えば、ユーザー情報を管理するテーブルがあるとします。このテーブルは以下の2つのフィールドを持っているとしましょう：

- userId: ユーザーID（パーティションキー）
- email: メールアドレス

通常、このテーブルはuserIdでクエリされますが、時にはemailでユーザーを探したいこともあるでしょう。そこで、反転インデックスを設定すると、emailをパーティションキーとした別のインデックスが作られ、メールアドレスでのクエリが高速化されます。

```plaintext
Main Table:
Partition Key: userId
Sort Key: email

Inverted Index (GSI):
Partition Key: email
Sort Key: userId
```

</details>
